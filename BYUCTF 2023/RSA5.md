# RSA5
```python
from Crypto.Util.number import long_to_bytes 
from numpy import gcd ,mod
n = 158307578375429142391814474806884486236362186916188452580137711655290101749246194796158132723192108831610021920979976831387798531310286521988621973910776725756124498277292094830880179737057636826926718870947402385998304759357604096043571760391265436342427330673679572532727716853811470803394787706010603830747
e1 = 65537

c1 = 147465654815005020063943150787541676244006907179548061733683379407115931956604160894199596187128857070739585522099795520030109295201146791378167977530770154086872347421667566213107792455663772279848013855378166127142983660396920011133029349489200452580907847840266595584254579298524777000061248118561875608240

e2 = 65521

c2 = 142713643080475406732653557020038566547302005567266455940547551173573770529850069157484999432568532977025654715928532390305041525635025949965799289602536953914794718670859158768092964083443092374251987427058692219234329521939404919423432910655508395090232621076454399975588453154238832799760275047924852124717
u=-4095  #tìm u,v thông qua e1*u + e2*v = 1 và áp dụng euclid mở rộng
v=4096

# c1_inv là kết quả của nghịch đảo của c modul n
c1_inv = 41927986095072457444217736683837680663124015714519624826567637473436840224329050796518412622704248843623876460470352658796681519749838102909966117084980630961538920888206501864603139250353935696568348581578810754609263580820375423804224092959000250716559616575897834442887109531283082744504538831190992012975
m= (pow(c1_inv,-u) * pow(c2,v))%n
print(long_to_bytes(m))
# flag: byuctf{NEVER_USE_SAME_MODULUS_WITH_DIFFERENT_e_VALUES}
```
- Material [``here``](https://youtu.be/EYw98NC79eI) and [``here``](https://bitsdeep.com/posts/attacking-rsa-for-fun-and-ctf-points-part-1/)
```
In this scenario, imagine that several persons are communicating over a public network. Because they didn’t want to generate a different modulus for each person, they decided that every person will have the same modulus.
Each user i will have a unique public key (N, e_i) and unique private key (N, d_i).
You managed to intercept an important message M sent to users A and B. But because it’s encrypted, you have in your possession C_A and C_B. How can you recover it ?

Compute gcd(e_A,e_B), it should be equal to 1. Using Bézout’s identity we know that there exist u and v so that e_A*u + e_B*v = 1.
You can compute u and v using the extended Euclidean algorithm.

C_A = M^{e_A} and C_B = M^{e_B}
C_A^u = M^{e_A^u} = M^{e_A*u} do the same to C_B

You can now multiply both to make the Bézout’s identity appear.

M^{e_A*u}*M^{e_B*v} = M^{e_A*u+e_B*v} = M^1 = M

Example :

n = 19085995833312192524007220630153244389942263922006889142154298425751808612835625879164268530070480609
Here are the public keys of person 1 and 2 and the ciphertexts you intercepted:

e1 = 31
e2 = 71
c1 = 6754157603566559210605055806173167464578011342930319568190139207096747909338872956835503565519657656L
c2 = 15442865769085690326152463737212582797117727243803209188030346754687972404658825954014788039636105165L
Apply Bézout’s identity and find u = 55 and v = -24. Because v < 0 you’ll need to compute the inverse of c_2 modulo n which is :

c2_inv = 12909978039651622455828981512398791612880793088232603583312672024505111979731377532780209633970663146
Now you just compute M = c_1^u*c_2_{inv}^{-v} which gives you the decrypted message :

M
101519529085530394070280463104338208011199968387105
hex(M)
'0x45766520697320737079696e67206f6e2075732021L'
"45766520697320737079696e67206f6e2075732021".decode('hex')
'Eve is spying on us !'
```
