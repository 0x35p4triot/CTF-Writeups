

# This file was *autogenerated* from the file sage.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2)
from sage.all import *
from Crypto.Util.number import bytes_to_long, long_to_bytes
from output import enc

# Decryption function
def decrypt(e, p, PT):
    R = GF(p)['x']; (x,) = R._first_ngens(1)
    # Reconstruct the polynomial from the points
    f = R.lagrange_polynomial(PT)
    # Get the coefficients of the polynomial
    C = f.coefficients(sparse=False)
    
    # The last coefficient is the encrypted message m^e % p
    m_e_mod_p = int(C[-_sage_const_1 ])
    
    # Convert e and p-1 to Sage integers
    sage_e = Integer(e)
    sage_p_minus_1 = Integer(p - _sage_const_1 )
    
    # Compute the modular inverse of e modulo p-1
    d = sage_e.inverse_mod(sage_p_minus_1)
    
    # Recover the original message m
    m = pow(m_e_mod_p, d, p)
    
    # Convert the long integer back to bytes
    msg = long_to_bytes(m)
    
    return msg

# Extracting the encrypted components
e = int(enc[_sage_const_0 ])
p = int(enc[_sage_const_1 ])
PT = enc[_sage_const_2 ]

# Ensure PT points are properly formatted as tuples
PT = [(int(a), int(b)) for a, b in PT]

# Decrypt the message
decrypted_msg = decrypt(e, p, PT)
print(f'decrypted message: {decrypted_msg}')

